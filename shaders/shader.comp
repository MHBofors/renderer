#version 460
#define MAX_ITER 512
#define PALLETE_SIZE 3
#define PI (3.1415926535897932384626433832795)
#define PHI 1.618033988
#define R_SQUARED 1e15
#define MAX(a,b) (a < b ? b : a)
#define MIN(a,b) (a < b ? a : b)

#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)
#define conjugate(a) vec2(a.x,-a.y)
#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))

layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, set = 0, binding = 0) uniform image2D image;
layout(push_constant) uniform constants {
    float x_min;
    float x_max;
    float y_min;
    float y_max;
    float re;
    float im;
    float t;
    int pad;
};

vec2 c = vec2(re, im);

vec3 palette[PALLETE_SIZE + 1] = {
    vec3(.95, .075, .075),
    vec3(.075, .75, .075),
    vec3(.075, .075, .75),
    vec3(.95, .075, .075),
};

/*
vec3 cross(vec3 u, vec3 v) {
    return vec3(u.y*v.z - u.z*v.y, u.z*v.x - u.x*v.z, u.x*v.y - u.y*v.x);
}
*/

float unit_wave(float x) {
    return (1.0 - sin(x)) * 0.5;
}


vec3 renorm(vec3 X, uint n) {
    vec3 X_new = vec3(pow(X.x, n), pow(X.y, n), pow(X.z, n));
    float norm = pow(X_new.x*X_new.x + X_new.y*X_new.y + X_new.z*X_new.z, 1/float(2*n));
    return X_new/norm;
}

vec2 cmult(vec2 a, vec2 b) {
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y);
}

vec2 clog(vec2 a) {
    float re = 0.5*log(a.x*a.x + a.y*a.y);
    float im = atan(a.x, a.y);

    if(im > PI) {
        im -= 2*PI;
    }
    return vec2(re, im);
}

vec2 cexp(vec2 z) {
    return exp(z.x)*vec2(cos(z.y), sin(z.y));
}

vec2 csin(vec2 z) {
    return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y));
}

vec2 ccos(vec2 z) {
    return vec2(cos(z.x)*cosh(z.y), -sin(z.x)*sinh(z.y));
}

vec2 cpow(vec2 z, float x) {
    float r = pow(z.x*z.x + z.y*z.y, 0.5*x);
    float theta = atan(z.x, z.y)*x;

    return r*vec2(cos(theta), sin(theta));
}

float f(float x) {
    return (1.0 - cos(PI*MAX(0.0, MIN(1.0, x))))*0.5;
}

float g(float x, float a, float b) {
    return f(x/a)*f(((b+a) - x)/b);
}

float d(vec2 z_0) {
    vec2 z = z_0;
    float d_squared = 1.0;
    float m_squared = z.x*z.x + z.y*z.y;
    float a, b;

    for(int i = 0; i < MAX_ITER && m_squared < R_SQUARED; i++) {
        d_squared *= 4.0*m_squared;
        a = z.x*z.x, b = z.y*z.y;
        z = vec2((a - b), (2*z.x*z.y)) + c;
        m_squared = a + b;
    }

    return sqrt(m_squared/d_squared)*0.5*log(m_squared);
}



uint julia_number(vec2 z) {
    uint iteration = 0;
    while(z.x*z.x + z.y*z.y < 2048.0f && iteration++ < MAX_ITER) {
        z = vec2((z.x*z.x - z.y*z.y), (2*z.x*z.y)) + c;
    }

    return iteration;
}

uint julia2_number(vec2 z) {
    uint iteration = 0;
    while(z.x*z.x + z.y*z.y < 2048.0f && iteration++ < MAX_ITER) {
        vec2 z_squared = product(z, z);
        vec2 z_cubed = product(z_squared, z);
        vec2 z_quint = product(z_squared, z_cubed);
        z = z_quint - 0.01*divide(vec2(1, 0), z_cubed) + 0.01*divide(vec2(0, -1), z_squared) + c;
    }

    return iteration;
}

uint julia3_number(vec2 z) {
    uint iteration = 0;
    while(z.x*z.x + z.y*z.y < 4056.0f && iteration++ < MAX_ITER) {
        vec2 z_squared = product(z, z);
        vec2 z_cubed = product(z_squared, z);
        vec2 z_quint = product(z_squared, z_cubed);
        z = cexp(divide(c, (z_quint)));//Flower
        //z = 0.6*clog(divide(c, (z_quint)));
        //z = z_quint + c + z/float(iteration);
    }

    return iteration;
}

uint julia5_number(vec2 z) {
    uint iteration = 0;
    while(z.x*z.x + z.y*z.y < 4096.0f && iteration++ < MAX_ITER) {
        z = csin(z + c);
        //vec2 z_squared = product(z, z);
        //vec2 z_cubed = product(z_squared, z);
        //vec2 z_quint = product(z_squared, z_cubed);
    }

    return iteration;
}

vec2 julia4_number(vec2 z) {
    uint iteration = 0;
    while(z.x*z.x + z.y*z.y < float(1<<30) && iteration++ < 1<<3) {
        z = cexp(z) + c;
    }

    return z;
}

float normalised_iteration_number(uint n) {
    return mod(pow(pow(float(n)/float(MAX_ITER), 0.2)*PALLETE_SIZE, 1.5), PALLETE_SIZE);
}

vec3 color(float v) {
    v += t;
    uint m = uint(mod(floor(v), PALLETE_SIZE));
    uint n = uint(mod(ceil(v), PALLETE_SIZE));
    float r = fract(v);

    //return (1 - r)*palette[m] + r*palette[n];
    //vec3 color1 = vec3(unit_wave(v), unit_wave(PHI*v + 1), unit_wave((PHI + 1)*v + 2));
    vec3 color = (1 - r)*palette[m] + r*palette[n];
    return color;
}

vec3 color_alt(float v) {
    uint m = uint(mod(floor(v), PALLETE_SIZE));
    uint n = uint(mod(ceil(v), PALLETE_SIZE));
    float r = fract(v);

    //return (1 - r)*palette[m] + r*palette[n];
    //vec3 color1 = vec3(unit_wave(v), unit_wave(PHI*v + 1), unit_wave((PHI + 1)*v + 2));
    vec3 color = (1 - r)*palette[m] + r*palette[n];
    return color;
}

vec3 ccolor(vec2 z) {
    float re = z.x;
    float im = z.y;
    float q = 2.0*PI/3.0;
    float theta = atan(re, im);
    
    float u = fract(re);
    float v = fract(im);

    float r = 8.0*u*v*(1.0 - u)*(1.0 - v);
    vec3 color = r*vec3(unit_wave(theta), unit_wave(theta + q), unit_wave(theta + 2.0*q));

    return color;
}

vec3 ccolor2(vec2 z) {
    float re = z.x;
    float im = z.y;
    float q = 2.0*PI/3.0;
    float theta = atan(re, im);
    
    float r = fract(length(z));

    r = 4.0*r*(1.0 - r);
    vec3 color = r*vec3(unit_wave(theta), unit_wave(theta + q), unit_wave(theta + 2.0*q));

    return color;
}

vec3 ccolor3(vec2 z) {
    float re = z.x;
    float im = z.y;
    float r = length(z);
    uint m = uint(mod(floor(r), PALLETE_SIZE));
    float s = fract(r);

    vec3 color = (1 - s)*palette[m] + s*palette[m + 1];
    return color;
}

/*
vec3 color_alt2(float v) {
    v += t;
    float red = (1+unit_wave(0.5*v + 3*t + 1))*0.5;
    red = (1+4.0*pow(g(mod(-(v+4*t), 4 + 1), 4, 1), 1))*0.2;
    float green = unit_wave(v - 5*t + 2)*0.15;
    green = (pow(g(mod(-(v+2*PHI*t), 10 + 1), 10, 1), 1))*0.2;
    float blue = (1+unit_wave(v + 11*t + 3))*0.25;
    blue = (1+2*pow(g(mod(-(v+4*PI*t), 12 + 1), 12, 1), 1))*0.2;

    vec3 color = vec3(red, green, blue);
    return color;
}
*/

vec3 color_gradient(vec2 z, float t) {
    return vec3((unit_wave(z.x + t) + unit_wave(z.y + 2*t))/2, (unit_wave(z.x + 3*t + 1) + unit_wave(z.y + t))/2, (unit_wave(z.x + 3*t) + unit_wave(z.y + 2*t + 3))/2);
}

/*
vec3 dem_j(vec2 z, float t) {
    float v = d(z);
    
    if(v > 0) {
        imageStore(image, texel_coordinate, vec4(color(-log(v)), 1));
    } else {
        //float r = length(z);
        //imageStore(image, texel_coordinate, vec4(0.0, 0.0, 0.0, 1.0));
        vec4 color_gradient = vec4(color_gradient(z, t), 1.0);
        imageStore(image, texel_coordinate, color_gradient);
    }
}
*/

void main() {
    ivec2 texel_coordinate = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(image);

    float aspect_ratio = float(size.y)/float(size.x);

    vec2 z = -vec2(aspect_ratio*(float(gl_GlobalInvocationID.x)/float(size.x) - 0.5), float(gl_GlobalInvocationID.y)/float(size.y) - 0.5);
    z *= 2.82;
    z *= 0.125;
    //z *= 5.25;
    //z.x -= 0.5;
    //z.y += 0.00125;

    //uint m = julia3_number(z);
    //float v = normalised_iteration_number(m);
    float v = d(z);
    if(v > 0) {
        imageStore(image, texel_coordinate, vec4(color(-log(v)-8*t), 1));
    } else {
        vec4 color_gradient = vec4(color_gradient(z, t), 1.0);
        imageStore(image, texel_coordinate, color_gradient);
    }

    /*
    if(m >= MAX_ITER-1) {
        vec4 color_gradient = vec4(color_gradient(z, t), 1.0);
        imageStore(image, texel_coordinate, color_gradient);
    } else {
        imageStore(image, texel_coordinate, vec4(color_alt(-t-log(v)), 1));
    }
    */
}